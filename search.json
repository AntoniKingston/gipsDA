[{"path":"https://AntoniKingston.github.io/gipsDA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Antoni Zbigniew Kingston. Author. Norbert Maksymilian Frydrysiak. Author, maintainer. Adam Przemysław Chojecki. Contributor.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kingston AZ, Frydrysiak NM (2026). gipsDA: Training DA Models Utilizing gips. R package version 0.1.","code":"@Manual{,   title = {gipsDA: Training DA Models Utilizing gips},   author = {Antoni Zbigniew Kingston and Norbert Maksymilian Frydrysiak},   year = {2026},   note = {R package version 0.1}, }"},{"path":"https://AntoniKingston.github.io/gipsDA/index.html","id":"gipsda","dir":"","previous_headings":"","what":"Training DA Models Utilizing gips","title":"Training DA Models Utilizing gips","text":"R package discriminant analysis classification using covariance matrices permutation symmetries.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/index.html","id":"about-the-project","dir":"","previous_headings":"","what":"About The Project","title":"Training DA Models Utilizing gips","text":"gipsDA R package extends classical Linear Discriminant Analysis (LDA) Quadratic Discriminant Analysis (QDA) incorporating permutation group structures estimation covariance matrices. leveraging methodology gips library, package aims improve classification performance scenarios features (variables) exhibit underlying symmetries. core idea find impose permutation symmetry covariance matrix, acts form regularization can lead stable interpretable models, especially high-dimensional settings. ultimate goal submit gipsDA Comprehensive R Archive Network (CRAN).","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/index.html","id":"key-features","dir":"","previous_headings":"About The Project","what":"Key Features","title":"Training DA Models Utilizing gips","text":"Implementation four novel gips-based discriminant analysis classifiers. flexible, user-friendly model API consistent established machine learning libraries R. specialized gipsmult module modeling class-specific covariances shared symmetry. Designed following best practices R package development.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/index.html","id":"r-package-structure","dir":"","previous_headings":"","what":"R Package Structure","title":"Training DA Models Utilizing gips","text":"adopt best practices R package development, repository organized following standard structure: gipsmult_: files belonging gipsmult module. models_: files belonging models module. tests/ directory houses testing scripts ensure reliability correctness package. Automated unit tests implemented using testthat framework designed verify functionality individual functions methods within modules.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/index.html","id":"available-models-in-gipsda","dir":"","previous_headings":"","what":"Available Models in gipsDA","title":"Training DA Models Utilizing gips","text":"gipsDA object can configured run one four different classification algorithms, different assumptions data structure. gipsLDA_weighted_average approach, separate covariance matrix first estimated class. final, single covariance matrix computed weighted average individual matrices. pooled matrix processed gips library used classification. gipsLDA_classic model follows traditional approach using classic pooled covariance estimator standard traditional LDA. single, pooled matrix processed gips library find probable permutation symmetry. gipsMultQDA model leverages gipsmult module. process involves first identifying single probable permutation structure common across classes. Subsequently, separate covariance matrix estimated class, matrix projected onto shared permutation. gipsQDA represents flexible model. gips library applied independently class. Consequently, class can uniquely estimated permutation structure distinct covariance matrix. analogous classic QDA framework individualized symmetry discovery class.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":null,"dir":"Reference","previous_headings":"","what":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"precisely, logarithm unnormalized posterior probability. goal function optimization algorithms find_MAP() function. perm_proposal maximizes function Maximum Posteriori (MAP) Estimator.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"","code":"log_posteriori_of_gipsmult(g)"},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"g object gips class.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"Returns value logarithm unnormalized Posteriori.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"calculated using formulas (33) (27) references. Inf NaN reached, produces warning.","code":""},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"Piotr Graczyk, Hideyuki Ishi, Bartosz Kołodziejek, Hélène Massam. \"Model selection space Gaussian models invariant symmetry.\" Annals Statistics, 50(3) 1747-1774 June 2022. arXiv link; doi:10.1214/22-AOS2174","code":""},{"path":[]},{"path":"https://AntoniKingston.github.io/gipsDA/reference/log_posteriori_of_gipsmult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A log of a posteriori that the covariance matrix is invariant under permutation — log_posteriori_of_gipsmult","text":"","code":"# In the space with p = 2, there is only 2 permutations: perm1 <- permutations::as.cycle(\"(1)(2)\") perm2 <- permutations::as.cycle(\"(1,2)\") S1 <- matrix(c(1, 0.5, 0.5, 2), nrow = 2, byrow = TRUE) g1 <- gips(S1, 100, perm = perm1) #> Error in gips(S1, 100, perm = perm1): could not find function \"gips\" g2 <- gips(S1, 100, perm = perm2) #> Error in gips(S1, 100, perm = perm2): could not find function \"gips\" log_posteriori_of_gips(g1) # -134.1615, this is the MAP Estimator #> Error in log_posteriori_of_gips(g1): could not find function \"log_posteriori_of_gips\" log_posteriori_of_gips(g2) # -138.1695 #> Error in log_posteriori_of_gips(g2): could not find function \"log_posteriori_of_gips\"  exp(log_posteriori_of_gips(g1) - log_posteriori_of_gips(g2)) # 55.0 #> Error in log_posteriori_of_gips(g1): could not find function \"log_posteriori_of_gips\" # g1 is 55 times more likely than g2. # This is the expected outcome because S[1,1] significantly differs from S[2,2].  compare_posteriories_of_perms(g1, g2) #> Error in compare_posteriories_of_perms(g1, g2): could not find function \"compare_posteriories_of_perms\" # The same result, but presented in a more pleasant way  # ========================================================================  S2 <- matrix(c(1, 0.5, 0.5, 1.1), nrow = 2, byrow = TRUE) g1 <- gips(S2, 100, perm = perm1) #> Error in gips(S2, 100, perm = perm1): could not find function \"gips\" g2 <- gips(S2, 100, perm = perm2) #> Error in gips(S2, 100, perm = perm2): could not find function \"gips\" log_posteriori_of_gips(g1) # -98.40984 #> Error in log_posteriori_of_gips(g1): could not find function \"log_posteriori_of_gips\" log_posteriori_of_gips(g2) # -95.92039, this is the MAP Estimator #> Error in log_posteriori_of_gips(g2): could not find function \"log_posteriori_of_gips\"  exp(log_posteriori_of_gips(g2) - log_posteriori_of_gips(g1)) # 12.05 #> Error in log_posteriori_of_gips(g2): could not find function \"log_posteriori_of_gips\" # g2 is 12 times more likely than g1. # This is the expected outcome because S[1,1] is very close to S[2,2].  compare_posteriories_of_perms(g2, g1) #> Error in compare_posteriories_of_perms(g2, g1): could not find function \"compare_posteriories_of_perms\" # The same result, but presented in a more pleasant way"}]
