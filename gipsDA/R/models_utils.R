# Helper: compute project a covariance / scatter matrix with gips
project_cov <- function(emp_cov, n_obs, MAP = TRUE, optimizer, max_iter, tol = 1e-3) {
    # build gips object from empirical covariance / scatter and n
    gg <- gips::gips(emp_cov, n_obs, was_mean_estimated = TRUE)
    # optimize to find MAP
    if (MAP){
        gg <- gips::find_MAP(gg, optimizer = optimizer, max_iter = max_iter)
        perm <- gg[[1]]
        # project matrix onto invariants of cyclic group generated by perm
        return(gips::project_matrix(emp_cov, perm))
    }
    gg <- gips::find_MAP(gg, optimizer = optimizer, max_iter = max_iter, return_probabilities = TRUE, save_all_perms = TRUE)
    probs <- gips::get_probabilities_from_gips(gg)
    probs <- probs[probs > tol]
    return(project_matrix_multiperm(emp_cov, probs))
}

project_covs <- function(emp_covs, ns_obs, MAP = TRUE, optimizer, max_iter, tol = 1e-3) {
    gg <- gipsmult(emp_covs, ns_obs, was_mean_estimated = TRUE)
    if (MAP) {
        gg <- find_MAP(gg, optimizer = optimizer, max_iter = max_iter)
        perm <- gg[[1]]
        return(lapply(emp_covs, function(x) gips::project_matrix(x, perm)))
    }
    gg <- find_MAP(gg, optimizer = optimizer, max_iter = max_iter, return_probabilities = TRUE, save_all_perms = TRUE)
    probs <- get_probabilities_from_gipsmult(gg)
    probs <- probs[probs > tol]
    return(lapply(emp_covs, function(x) project_matrix_multiperm(x, probs)))
}



project_matrix_multiperm <- function(emp_cov, probs) {
    perms <- names(probs)
    projected_matrix <- matrix(0, nrow = dim(emp_cov), dim(emp_cov))
    for (i in 1:length(probs)) {
        projected_matrix <- projected_matrix + probs[[i]] * gips::project_matrix(emp_cov, perms[i])
    }
    return(projected_matrix)
}

